2.1 Ruby Is an Object-Oriented Language
====
Let’s say it again. Ruby is a genuine object-oriented language. Everything you manipulate is an object, and the results of those manipulations are themselves objects. However, many languages make the same claim, and their users often have a different interpretation of what ​object-oriented​ means and a different terminology for the concepts they employ.

So, before we get too far into the details, let’s briefly look at the terms and notation that ​we’ll​ be using.


When you write object-oriented programs, you’re normally looking to model concepts from the real world. During this modeling process you’ll discover categories of things that need to be represented in code. In a jukebox, the concept of a “song” could be such a category. In Ruby, you’d define a ​ class​ to represent each of these entities. A class is a combination of state (for example, the name of the song) and methods that use that state (perhaps a method to play the song).

Once you have these classes, you’ll typically want to create a number of ​ instances​ of each. For the jukebox system containing a class called ​Song​, you’d have separate instances for popular hits such as “Ruby Tuesday,” “Enveloped in Python,” “String of Pearls,” “Small Talk,” and so on. The word ​ object​ is used interchangeably with ​class instance​ (and being lazy typists, we’ll probably be using the word ​object​ more frequently).

In Ruby, these objects are created by calling a ​constructor​, a special method associated with a class. The standard constructor is called ​new​ .
```ruby
song1 = Song.new(​"Ruby Tuesday"​)​ 	
song2 = Song.new(​"Enveloped in Python"​)​ 	
​# and so on​
```

These instances are both derived from the same class, but they have unique characteristics. First, every object has a unique ​ object identifier​ (abbreviated as ​object ID​). Second, you can define ​ instance variables​ , variables with values that are unique to each instance. These instance variables hold an object’s state. Each of our songs, for example, will probably have an instance variable that holds the song title.

Within each class, you can define ​ instance methods​ . Each method is a chunk of functionality that may be called in the context of the class and (depending on accessibility constraints) from outside the class. These instance methods in turn have access to the object’s instance variables and hence to the object’s state. A ​Song​ class, for example, might define an instance method called ​play​ . If a variable referenced a particular ​Song​ instance, you’d be able to call that instance’s ​play​ method and play that song.
Methods are invoked by sending a message to an object. The message contains the method’s name, along with any parameters the method may need.[15] When an object receives a message, it looks into its own class for a corresponding method. If found, that method is executed. If the method ​isn’t​ found...well, we’ll get to that later.

This business of methods and messages may sound complicated, but in practice it is very natural. Let’s look at some method calls. In this code, we’re using ​puts​ , a standard Ruby method that writes its argument(s) to the console, adding a newline after each:
```ruby
puts ​"gin joint"​.length​ 	
puts ​"Rick"​.index(​"c"​)​ 	
puts 42.even?​ 	
puts sam.play(song)
```
Produces:
```ruby
9​ 	
2​ 	
true​ 	
duh dum, da dum de dum ...
```
Each line shows a method being called as an argument to ​puts​ . The thing before the period is called the ​ receiver​ , and the name after the period is the method to be invoked. The first example asks a string for its length; the second asks a different string to find the index of the letter ​c​. The third line asks the number 42 if it is even (the question mark is part of the method name ​even?​ ). Finally, we ask Sam to play us a song (assuming there’s an existing variable called ​sam​ that references an appropriate object).

It’s worth noting here a major difference between Ruby and most other languages. In (say) Java, you’d find the absolute value of some number by calling a separate function and passing in that number. You could write this:
```ruby
num = ​Math​.abs(num)     ​// Java code​
```
In Ruby, the ability to determine an absolute value is built into numbers—they take care of the details internally. You simply send the message ​abs​ to a number object and let it do the work:
```ruby​ 	
num      = -1234   ​# => -1234​
positive = num.abs ​# => 1234​
```
The same applies to all Ruby objects. In C you’d write ​strlen(name)​, but in Ruby it would be ​name.length​, and so on. This is part of what we mean when we say that Ruby is a genuine object-oriented language.




2.1 Ruby是一门面向对象的语言
======
重申一遍，Ruby是真正的面向对象语言。你操作的一切都是对象，返回的结果也是对象。然而，很多语言同样声称是面向对象的语言，但使用者常会对"面向对象"有不同的解释，也会用不同的术语来说明他们所使用的概念。

所以，在深入细节之前，我们先简略地看一下，我们将要用到的术语和程序语言的表示法。

当你在写面向对象的程序时，你得根据实际情况来对内容进行建模。在这个过程中，在这个过程中你需要找出要用代码表达的事物种类。在点歌系统(jukebox)中，“歌曲”的概念可能就是一个种类。在Ruby中，你需要用类(class)来代表这些实体。一个类是内容(例如,歌曲名称)和使用这些内容的方式(例如，播放歌曲)的组合。

一旦你建立了这些类，通常你要为每个类创建若干个实例(instances)。在点歌系统中，可以包含一个名为“Song”的类，你可以单独的为“Ruby Tuesday,” “Enveloped in Python,” “String of Pearls,” “Small Talk,”等歌曲分别建立实例。“对象(object)”和“类的实例(class instance)”含义相同。（我们比较懒，所以会更常用对象这个词）。

在Ruby中，通过调用构造函数(constructor)来创建新对象，构造函数是与类相关联的特殊方法。标准的构造函数称为`new`
```ruby
song1 = Song.new(​"Ruby Tuesday"​)​ 	
song2 = Song.new(​"Enveloped in Python"​)​ 	
​# and so on​
```


这些实例虽然来自同一个类，但是他们有不同的特征。首先，每个类都有唯一的对象标示符( object identifier​，缩写为object ID​)。其次，你可以定义一些实例变量(instance variables),这些实例变量的值对每个实例都是唯一。这些实例变量都保存着对象的内容，例如，每首歌曲每首歌曲都会有一个实例变量在保存歌曲的名字。

可以为每个类定义实例方法。每个方法都是功能的组合，他们可能会在类的内部或者类的外部(取决于访问控制)被调用。这些实例方法会放过来访问对象的实例变量及其状态。例如，类“Song”有实例方法叫“play”，如果一个变量在特定的歌曲实例，你就能调用实例里的“play”方法来播放歌曲。

方法是通过对象传递消息来调用的。消息包括方法的名称以及可能需要的参数。当一个对象收到一条消息时，它会在自己的类中查找相应的方法。如果找到了就执行该方法。如果没有的话......我们会后面讲到这一点。

方法和消息自检的关系可能听起来比较复杂，但是实际上非常自然。让我们来看一些方法调用。在下面的代码中，我们把`puts`和它的参数写到控制台里面，每一个都添加一个换行符。

```ruby
puts ​"gin joint"​.length​ 	
puts ​"Rick"​.index(​"c"​)​ 	
puts 42.even?​ 	
puts sam.play(song)
```
Produces:
```ruby
9​ 	
2​ 	
true​ 	
duh dum, da dum de dum ...
```
每一行调用了带一个参数的`puts`方法。在点好（“.”）之前被称为接受者(receiver),点好之后的被称为调用的方法。第一个例子是获取字符串的长度，第二个例子是在字符串中找到字母'c'第一次出现的位置，第三个
判断数字42是不是偶数(问号是方法的一部分)。最后一个是要求Sam播放一首歌曲(假设这里存在一个实例变量叫sam来引用合适的对象)。

值得注意的是在Ruby和大多数语言有很大的区别。在Java中，你发现你是通过调用另外的方法来求num的绝对值，然后把载传回num。你如下面的代码：
```ruby
num = ​Math​.abs(num)     ​// Java code​
```
在Ruby中，求绝对值的能力是在数字里，处理的细节在内部实现。你只要简单的发送一个消息abs到数字对象，它自己就会完成求绝对值。
```ruby​ 	
num      = -1234   ​# => -1234​
positive = num.abs ​# => 1234​
```
这同样适合所有的Ruby对象。在C语言中你需要写 strlen(name),Ruby中使用name.length,诸如此类。所以，正如我们所说的，Ruby是一门真正的面向对象的语言
