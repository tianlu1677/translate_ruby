2.7 Block块和迭代器 （Blocks and Iterators）
====
本节会简单的介绍Ruby的一个独特优势。代码块(code blocks​)就像参数一样，一种能和方法调用相关联的代码片段，是一种难以置信的强大特性。一个评论家说：“code blocks 非常有趣和重要，如果你之前没有关注，那么现在你就应该重视起来了。” 我们举双手赞同。

你可以用代码块(code blocks)来实现函数回调(但它比Java的anonymous inner classes更简单)、传递一组代码(但它比C的函数指针更灵活)以及实现迭代。
代码块(code blocks)是在 花括号或者 do ... end 之间的一组代码。下面就是代码块。

```ruby
{ puts ​"Hello"​ }
```
This is also a code block:
```
​do​​	
  club.enroll(person)​ 	
  person.socialize​ 	
​end​
```
为什么会有两种写法？部分原因是有人觉得一种写法比另外一种写法更自然。另外原因是两者有不同的优先级：花括号比do/end有更高的优先级。在本书中，我们尽量遵守Ruby的标准，单行的代码块用花括号，多行的代码块用do/end。

你所要做的就是把 block 和方法的调用关联起来。你把block放在方法调用行的结尾处，就可以实现方法调用了。比如，下面的代码，含有 `puts "Hi"`的
block与方法greet的调用关联起来(greet方法没有写出来)。

```ruby
greet  { puts ​"Hi"​ }
```

如果这个方法有参数，那么参数放在block前面。
```ruby
verbose_greet(​"Dave"​, ​"loyal customer"​)  { puts ​"Hi"​ }
```
然后一个方法可以使用Ruby的`yield`方法，一次或多次调用关联的(block)。你可以把yield想象成方法调用，它调用了包含yield语句的方法相关联的block( You can think of ​yield​ as being something like a method call that invokes the block associated with the call to the method containing the ​yield​.)

下面的例子，展示了如何使用yield语句。我们定义了一个调用yield两次的方法。然后，在同一行，调用这个方法时传给它block,
在方法调用之后(并在这个方法的所有参数之后)。( We then call this method, putting a block on the same line, after the call (and after any arguments to the method).[18])
```ruby
​def​ call_block​ 	
  puts ​"Start of method"​​ 	
  ​yield​​ 	
  ​yield​​ 	
  puts ​"End of method"​​ 	
​end​​ 	
​ 	
call_block { puts ​"In the block"​ }
```
Produces:
```ruby
Start of method​ 	
In the block​ 	
In the block​ 	
End of method
```
`puts "In the block"`被调用了两次，每次调用yield，代码都会被执行。
你可以传递参数到yield的调用，参数会被传递到block中。在block中，竖线(|params...|)之间给出参数名来接受这些来自yield的参数。（ Within the block, you list the names of the parameters to receive these arguments between vertical bars (​|params...|​). ）。下面的代码展示了，一个方法调用了两次与它相关联的的Block,并且每次传递两个参数：
```ruby
​def​ who_says_what​ 	
  ​yield​(​"Dave"​, ​"hello"​)​ 	
  ​yield​(​"Andy"​, ​"goodbye"​)​ 	
​end​ 	
who_says_what {|person, phrase| puts ​"​#{person}​ says ​#{phrase}​"​}
```
Produces:
```ruby
Dave says hello
Andy says goodbye
```
在Ruby库中大量使用代码块(code block)来实现迭代器，迭代器是从某个集合(collection)依次返回其中元素的方法，如理在数组中：

```ruby
animals = ​%w( ant bee cat dog )​    ​# create an array​
animals.each {|animal| puts animal }   ​# iterate over the contents​
```
Produces:
```ruby	
ant
bee
cat​ 	
dog
```

很多内建于C和Jva等语言的循环节后在Ruby中只是方法调用，这些方法会零次或多次的调用相关联的block:
```ruby
[ ​'cat'​, ​'dog'​, ​'horse'​ ].each {|name| print name, ​" "​ }​ 	
5.times {  print ​"*"​ }​ 	
3.upto(6) {|i|  print i }​ 	
(​'a'​..​'e'​).each {|char| print char }​ 	
puts
```
Produces:
```ruby
cat dog horse *****3456abcde
```
Here we ask an array to call the block once for each of its elements. Then, object 5 calls a block five times. Rather than use ​for​ loops, in Ruby we can ask the number 3 to call a block, passing in successive values until it reaches 6. Finally, the range of characters from ​a​ to ​e​ invokes a block using the method ​`each`​.

上面的代码中，第一个是，数组的每个元素都会调用一次block。第二个是，数字对象5 五次调用block。第三个中，我们不用循环，而是对象数字3调用一个block，并传入一个连续的值，直到这个值达到6为止。最后一个是，在字母 a到z的区间内，使用each方法调用block。